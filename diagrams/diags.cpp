#include <sstream>
#include <fstream>

#include "DiaGen.hpp"

/******************************************************************************
 *                                                                            *
 * QCDDiagram                                                                 *
 *                                                                            *
 ******************************************************************************/

class QCDDiagram : public Diagram
{
public:

  QCDDiagram(const Diagram& d) : Diagram(d) {};

private:

  virtual void
  print_vertex(ostream& output, int node, int fermion_chain_index = 0) const;
};

void
QCDDiagram::print_vertex(ostream& output, int n, int fermion_chain_index) const
{
  Vertex::pointer v = _vertex[n];
  const int degree = v->_original_fields.size();

  // determine the indices and momenta of the original vertex fields.
  // All the momenta are in-going and the indices are compatible with those
  // generated by print_line().

  vector<int> edge(degree);
  vector<string> index(degree);
  vector<vector<int> > momentum(degree);

  vector<bool> assigned(degree, false);

  for (int d = 0; d < 2; ++d)
    for (vector<int>::const_iterator e = _node_desc[n]._edges[d].begin();
	 e != _node_desc[n]._edges[d].end(); ++e)
      {
	for (int i = 0; i < degree; ++i)
	  {
	    if (!assigned[i] && _line[*e]._field[1-d] == v->_original_fields[i])
	      {
		assigned[i] = true;

		edge[i] = *e;

		ostringstream current_index;
		current_index << "v" << n << "l" << *e;

		if (_edge_desc[*e]._node[0] == _edge_desc[*e]._node[1])
                  {
                    if (d) current_index << "out";
                    else current_index << "in";
                  }

		index[i] = current_index.str();

		for (int j = 0; j < _momentum_basis.size(); ++j)
		  momentum[i].push_back((1-2*d)*_edge_desc[*e]._momentum[j]);

		break;
	      }
	  }
      }

  // make the map from the field type to the respective field position on
  // the original vertex field list.

  vector<vector<int> > position(Field::n_types);
  
  for (int i = 0; i < degree; ++i)
    position[v->_original_fields[i]->_type].push_back(i);

  // output according to the type

  switch (v->_type)
    {
    case Vertex::VectorScalar:
      {
	output << "\t*EikV(";
  print_momentum(output, momentum[0], _momentum_basis);
	output << ", " << index[2] << ")\n\t*(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n";
      }
      break;
    case Vertex::Identity:
      {
	output << "\t*(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n";
      }
      break;
    case Vertex::TripleVector:
      {
	output << "\t*VVV(";
	print_momentum(output, momentum[0], _momentum_basis);
	output << ", " << index[0] << ", ";
	print_momentum(output, momentum[1], _momentum_basis);
	output << ", " << index[1] << ", ";
	print_momentum(output, momentum[2], _momentum_basis);
	output << ", " << index[2] << ")\n\t*(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n";
      }
      break;
    case Vertex::QuadrupleVector:
      {
	output << "\t*(+d_(" << index[0] << ", " << index[1] << ")*d_("
	       << index[2] << ", " << index[3] << ")\n\t  *(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n\t  +d_(" << index[0] << ", " << index[2] << ")*d_(" 
	       << index[1] << ", " << index[3] << ")\n\t  *(";
	print_vertex_value(output, v->_value[1], n, edge);
	output << ")\n\t  +d_(" << index[0] << ", " << index[3] << ")*d_("
	       << index[1] << ", " << index[2] << ")\n\t  *(";
	print_vertex_value(output, v->_value[2], n, edge);
	output << "))\n";
      }	
      break;
    case Vertex::GhostVector:
      {
        if (v->_value.size() != 1)
          {
            cerr << "Diagram::print_vertex (GostVector): "
                 << "incompatible vertex structure" << endl;

            exit(1);
          }

        output << "\t*(";
        print_momentum(output, momentum[position[Field::Ghost][0]],
                       _momentum_basis, index[position[Field::Vector][0]]);
        output << ")*(";
        print_vertex_value(output, v->_value[0], n, edge);
        output << ")\n";
      }
      break;
    case Vertex::FermionVector:
      {
	output << "\t*G(" << fermion_chain_index << ", "
	       << index[position[Field::Vector][0]] << ")*(";
	print_vertex_value(output, v->_value[0], n, edge);
	output << ")\n";
      }
      break;
    default:
      break;
    }
}

/******************************************************************************
 *                                                                            *
 * print_diagram                                                              *
 *                                                                            *
 ******************************************************************************/

void
print_diagram(ostream& diags, int& n_diags, const Diagram& d)
{
  ////////////////////////////////////////////////////////////
  // number of closed fermion loops
  // only q-field loops are accepted
	  
  vector<vector<int> > closed_fermion_chains = d.closed_fermion_chains();
  /*for (vector<vector<int> >::iterator c = closed_fermion_chains.begin();
       c != closed_fermion_chains.end(); ++c)
    if (d.line(c->front()).first->_name == "Q") return;*/
  const int nl = closed_fermion_chains.size();



  ////////////////////////////////////////////////////////////
  // print
	  
  ++n_diags;

  diags << "*--#[ d" << n_diags << " :\n\n";
  d.print_info(diags);
  diags << "\n#define nl \"" << nl << "\"\n";
  diags << "\ng d" << n_diags << " =\n\n";

  QCDDiagram qcddiag(d);
  qcddiag.assign_momenta();
  qcddiag.print(diags);

  diags << "\n;\n\n";
  diags << "*--#] d" << n_diags << " :\n\n";
}

/******************************************************************************
 *                                                                            *
 * main                                                                       *
 *                                                                            *
 ******************************************************************************/

int main()
{
  // overriding the default vertex structure (consistent with QCDDiagram)

  int types[] =
    {
      0, 0, 0, 3, Vertex::TripleVector, 1,
      0, 0, 0, 4, Vertex::QuadrupleVector, 3,
      2, 0, 0, 1, Vertex::VectorScalar, 1,
      3, 0, 0, 0, Vertex::Identity, 1,
      0, 2, 0, 1, Vertex::GhostVector, 1,
      0, 0, 2, 1, Vertex::FermionVector, 1
    };
  
  Vertex::n_types = 6;
  Vertex::type_by_fields = types;

  Model QCD("fields", "vertices");

  // tree-level diagrams

  TopologyGenerator topologies0l(5,0);
  topologies0l.enable(TopologyGenerator::NoTadpoles);

  int n_diags = 0;

  ofstream diags0l("diags0l.out");
  
  while (topologies0l.next_topology())
    {
      // there are only massless fields in the Lagrangian
      // hence any (graph-theory) loop will yield a scaless integral
      if (topologies0l.current_topology().has_loops()) continue;

      DiagramGenerator diags(topologies0l.current_topology(),QCD,
                           {"A"},{"p1234"},{"q","qbar","g","g"},{"p1","p2","p3","p4"});
      
      
      
      while (diags.next_diagram()){
        bool internal_photon = false;
        for (int e = 0; e < diags.current_diagram().n_edges(); ++e)
            if ((!diags.current_diagram().is_external_edge(e)) && (diags.current_diagram().line(e).first->_name == "A")) { 
                internal_photon = true;
        } 
        if (!internal_photon) {
          print_diagram(diags0l,n_diags,diags.current_diagram());
        }
      }
    }

  diags0l << "#define ndiags \"" << n_diags << "\"\n";
  

  diags0l.close();
  
  // one-loop diagrams

  TopologyGenerator topologies1l(5,1);
  topologies1l.enable(TopologyGenerator::NoTadpoles);
  topologies1l.enable(TopologyGenerator::OnShell);

  n_diags = 0;

  ofstream diags1l("diags1l.out");
  
  while (topologies1l.next_topology())
    {
      // there are only massless fields in the Lagrangian
      // hence any (graph-theory) loop will yield a scaless integral
      if (topologies1l.current_topology().has_loops()) continue;

      DiagramGenerator diags(topologies1l.current_topology(),QCD,
                           {"A"},{"p1234"},{"q","qbar","g","g"},{"p1","p2","p3","p4"});

      while (diags.next_diagram()){
        bool internal_photon = false;
        for (int e = 0; e < diags.current_diagram().n_edges(); ++e)
            if ((!diags.current_diagram().is_external_edge(e)) && (diags.current_diagram().line(e).first->_name == "A")) { 
                internal_photon = true;
        } 
        if (!internal_photon) {
          print_diagram(diags1l,n_diags,diags.current_diagram());
        }
      }
    }

  diags1l << "#define ndiags \"" << n_diags << "\"\n";

  diags1l.close();

}
